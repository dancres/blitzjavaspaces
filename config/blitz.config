import net.jini.discovery.DiscoveryGroupManagement;

import java.util.logging.Level;

import java.net.InetSocketAddress;

import net.jini.security.BasicProxyPreparer;

import net.jini.core.discovery.LookupLocator;

import net.jini.jeri.tcp.TcpServerEndpoint;
import net.jini.jeri.ProxyTrustILFactory;
import net.jini.jeri.BasicILFactory;
import net.jini.jeri.BasicJeriExporter;
import net.jini.jrmp.JrmpExporter;

import org.dancres.blitz.stats.Switch;
import org.dancres.blitz.stats.OpSwitch;
import org.dancres.blitz.stats.InstanceSwitch;

import org.dancres.blitz.remote.debug.DebugILFactory;

import org.dancres.blitz.config.Persistent;
import org.dancres.blitz.config.TimeBarrierPersistent;
import org.dancres.blitz.config.Transient;
import org.dancres.blitz.config.EntryConstraint;
import org.dancres.blitz.config.CacheSize;
import org.dancres.blitz.config.Fifo;

import net.jini.core.entry.Entry;

import org.dancres.blitz.SpaceWriteTakeTest.TestEntry;

import org.dancres.blitz.remote.user.ColocatedAgent;

org.dancres.blitz {

	// *IfExists is a significant performance drain and by default Blitz aggressively
	// optimizes event delivery for those calls such that events from writes close to
	// the resolution point may be ignored.  If you are using *IfExists and require
	// completely deterministic behaviour, enable this option.  For those not using
	// *IfExists leave this option disabled for better performance.
	//
	syncNotifyOnWrite = true;
	
    // agents = new ColocatedAgent[] {new example.Init()};

    ignoreLogConfig = new Boolean(true);

    // Default logging level
    //
    // defaultLogLevel = Level.SEVERE;

    // Example of setting log levels for specific components
    //
    // org_dancres_blitz_disk_DiskLogLevel = Level.INFO;

    // Published on the proxy as a Name attribute
    //
    name = "dancres";

    // Set this to a LoginContext instance when you wish to run the server
    // as a particular principle
    //
    // loginContext =

    // Location to store meta info and entrys.
    // NOTE: Each concurrent Blitz instance should use a different directory
    // for it's logs and persistent state - if this isn't done
    // "bad things will happen" (TM)
    //
    persistDir = "/Users/dan/src/jini/blitzjavaspaces/dbfiles_dancres";

    // Location of log files - SHOULD BE DIFFERENT FROM ABOVE
    //
    logDir = "/Volumes/Data/log/dan/prevlog/";

    // Maximum number of async write threads
    // DO NOT CHANGE THIS - BLITZ DOESN'T SUPPORT MORE THAN ONE WRITE THREAD
    // (YET!)
    //
    maxWriteThreads = 1;

    // How long to keep write threads alive in the pool
    //
    // threadKeepalive = 15000;

    // The preferred queue size for pending writes
    //
    desiredPendingWrites = 256;
    // desiredPendingWrites = 16;

    // Size of the berkeley DB cache
    // You can run in 64Mb with this setting
    //
	dbCache = 27262976;
	
    // For this cache size, expect to use -Xmx128m
    //
	// dbCache = "32M";
	
    // For this cache size, expect to use -Xmx256m
    //
    // dbCache = 134217728;

    // Configures the maximum number of concurrent Db transactions
    // Bigger is better!  This value has been validated for 64 concurrent
    // JavaSpace operations
    //
    maxDbTxns = 256;

    // Dump Db statistics after every checkpoint if this is true
    //
    dumpDbStats = new Boolean(false);

    // Dump statistics for write queue usage
    // When tuning/configuring Blitz for various systems, these stats help
    // to determine I/O performance requirements and required memory
    //
    // dumpWQStats = new Boolean(true);

    // Turn this on to get reports on checkpointing behaviour - useful for
    // tuning
    logCkpts = new Boolean(false);

    // Maximum number of entry instances to cache for a particular Entry type
    //
    entryReposCacheSize = 4096;
    // entryReposCacheSize = 128;
    // entryReposCacheSize = 512;

    cacheEntriesPerPartition = 32;

    // Enable generic readahead for all types by setting this to non-zero.
    // Actual value determines how many Entry's will be loaded from disk
    // when readahead is activated.  Note this value should be smaller than
    // cache size.  As per cache size above, this can be set per Entry using
    // EntryConstraints as below for FIFO.
    //
    // entryReposReadahead = 256;

    // Type specific constraints - define a variable using the classname of
    // the type, replaceing . or $ with _.  The variable should then be
    // initialized to an array of EntryConstraints specifying requirements.
    // Note, if you wish to enable FIFO, reduce pendingWrites queue
    //
	
    // org_dancres_blitz_remote_test_SpaceFifonessTest_TestEntry =
    //    new EntryConstraint[] {new CacheSize(512), new Fifo()};
    
    // org_dancres_blitz_SpaceBlockTest_TestEntry =
    //    new EntryConstraint[] {new Fifo()};

    // org_dancres_blitz_SpaceFifonessTest_TestEntry =
    //    new EntryConstraint[] {new CacheSize(512), new Fifo()};

    // Non-blocking transactions are used within the entry package to
    // prevent deadlock.  Such transactions can fail and require aborting
    // should they fail to get a lock.  When this happens, the thread
    // attempting the transaction will backoff by an amount of time dictated
    // by base_backoff + Random(jitter) ms which should allow the conflicting
    // transaction time to complete.  Format is {base_backoff, jitter}
    loadBackoff = new int[] {20, 50};

    // The maximum allowable lease time for entries and notify registrations
    // To permit Lease.FOREVER, set the LeaseBound = 0.
    // To deny Lease.FOREVER and set an upper limit on lease time set the
    // LeaseBound to a positive non-zero value in milliseconds
    //
    entryLeaseBound = 0;
    notifyLeaseBound = 0;

    // How often to do an active cleanup of lease expired resources
    // Value should be ms - 0 disables active cleanup.  Normally, Blitz
    // uses read/take activity to do cleanup (passive).  If memory or
    // disk resource is scarce, configure this to non-zero to activate more
    // aggressive cleaning (which, in turn, is more CPU aggressive).
    //
    leaseReapInterval = 0;
    // leaseReapInterval = 60000;
    // leaseReapInterval = 1800000;

    // Number of OID allocators to use for entries
    maxOidAllocators = 512;

    // How often to log event allocation to disk
    //
    eventgenSaveInterval = 500;

    // How big a jump in notify sequence numbers there should be following
    // restart/crash
    //
    eventgenRestartJump = 1000;

    // Maximum number of task threads to be used in posting remote events
    // and dispatching blocked takes or reads
    //
    maxTaskThreads = 8;
    maxEventProcessors = 4;

    storageModel = new Transient();

    // storageModel = new TimeBarrierPersistent(true, true, 10000, 524288, 5000);

    // Persistent storage settings
    // Note:  The third parameter (batching time) can radically affect 
    // throughput in concurrent conditions.  You're advised to try various
    // settings for your desired load as variations in OS and hard-disk
    // performance determine what is appropriate for each machine.
	//
	// Note: the fourth parameter has changed behaviour. Most users likely have this set to true
	// which will select the concurrent (production-tested) batcher and represents the stable option.
	// Setting this parameter to false no longer selects the old (low performance) serial batcher, 
	// rather it enables an optimistic batcher that gives even higher performance than the concurrent
	// batcher.
    //
    // storageModel = new Persistent(true, true, 0, 500000, true, 10000, 32768);
    // storageModel = new Persistent(true, true, 1, false, 10000, 32768);

    statsDump = 60000;
	
    // Enable standard destroy semantics - by default, Blitz does NOT
    // delete state at destroy.  Enable that feature here and invoke
    // BlitzAdmin::shutdown to perform a shutdown whilst retaining state
    compliantDestroy = new Boolean(false);

    // Default Stats to make available
    stats = new Switch[] {new OpSwitch(OpSwitch.ALL_TYPES,
    		OpSwitch.TAKE_OPS, true),
    		new OpSwitch(OpSwitch.ALL_TYPES, OpSwitch.READ_OPS, true),
    		new OpSwitch(OpSwitch.ALL_TYPES, OpSwitch.WRITE_OPS, true),
    		new InstanceSwitch(InstanceSwitch.ALL_TYPES, true)};

    // The initial lookup groups to register with - after first boot
    // this information is held in a meta database and should be configured
    // via JoinAdmin
    //
    // initialGroups = new String[]{};
    // initialGroups = new String[]{"JERI_Group1"};
    // initialGroups = DiscoveryGroupManagement.ALL_GROUPS;


    // The initial lookup locators to register with - after first boot
    // this information is held in a meta database and should be configured
    // via JoinAdmin
    //
    // initialLocators = new LookupLocator[] {new LookupLocator("jini://rogue/")};

    // The initial attributes to register with - note that these need to be
    // available as part of the codebase.
    // This information is held in a meta database and should be configured
    // via JoinAdmin
    //
    // initialAttrs = new Entry[] {};

    // The exporter to use - see the JINI documentation
    //
    serverExporter = new BasicJeriExporter(
			  TcpServerEndpoint.getInstance(0),
                          new ProxyTrustILFactory(null, null), false, true);

    // This will enable the inbuilt debugging layer which displays client-side
    // method invocations and provides timing data
    //
    // serverExporter = new BasicJeriExporter(TcpServerEndpoint.getInstance(0),
    //                     new DebugILFactory(null, null), false, true);

    // For ACTIVATION, we must nest a normal exporter inside an activation
    // exporter instance.
    //
    // exporter= new BasicJeriExporter(TcpServerEndpoint.getInstance(0),
    //                                 new ProxyTrustILFactory(null, null), false, true);
	
    //use an ActivationExporter to create a persistent ref 	
    // serverExporter= new ActivationExporter((ActivationID) $data,exporter);

    // Enables the in-built loopback transaction manager - note the manager
    // can only be used to co-ordinate transactions against this blitz instance
    // it cannot co-ordinate multiple and/or remote participants such as other
    // Blitz instances [EXPERIMENTAL]
    //
    // loopbackTxnExporter =
    //     new BasicJeriExporter(TcpServerEndpoint.getInstance(0),
    //          new BasicILFactory(null, null), false, true);

    // Blitz provides a suitable default for all these but this is how you'd
    // configure them explicitly
    //
    notifyPreparer = new BasicProxyPreparer();
    recoveredNotifyPreparer = new BasicProxyPreparer();
    txnPreparer = new BasicProxyPreparer();
    recoveredTxnPreparer = new BasicProxyPreparer();
    activationIdPreparer = new BasicProxyPreparer();
    activationSysPreparer = new BasicProxyPreparer();
}
